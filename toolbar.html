<!doctype html>
<meta charset="utf-8" />
<title>Radial ‚Äî editor</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<img id="corner-logo" src="logo.png" alt="logo" />

<style>
  :root {
    color-scheme: light dark;
  }

  html,
  body {
    height: 100%;
    margin: 0;
    font: 14px system-ui, -apple-system, Segoe UI, Roboto;
  }

  #wrap {
    height: 100%;
    display: flex;
    flex-direction: column;
    background: #fff;
  }

  #ed {
    background-color: white;
    color: black;
    flex: 1 1 auto;
    width: 100%;
    border: 0;
    outline: none;
    padding: 12px;
    line-height: 1.5;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  }

  #corner-logo {
    position: fixed;
    bottom: 50px;
    /* distance from bottom */
    right: 0px;
    /* distance from right */
    width: 24px;
    height: 24px;
    z-index: 9999;
    /* make sure it's above other UI */
    cursor: pointer;
    /* optional: so it looks clickable */
  }


  #pv {
    color: black;
    flex: 1 1 auto;
    width: 100%;
    overflow: auto;
    padding: 12px;
    display: none;
  }

  #pv img {
    max-width: 100%;
    height: auto;
  }

  #bar {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    gap: 8px;
    border-top: 1px solid #e5e7eb;
    padding: 8px 10px;
    background: #fff;
    position: sticky;
    bottom: 0;
  }

  #tagdot {
    width: 14px;
    height: 14px;
    border-radius: 9999px;
    border: 1px solid #e5e7eb;
    display: inline-block;
    flex: 0 0 auto;
  }

  #name {
    flex: 1 1 auto;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 6px 8px;
    font-weight: 600;
    min-width: 120px;
  }

  #st {
    margin-left: auto;
    color: #64748b;
    font-size: 12px;
  }

  .btn {
    border: 1px solid #e5e7eb;
    background: #fff;
    border-radius: 8px;
    padding: 6px 8px;
    cursor: pointer;
  }
</style>

<div id="wrap">
  <textarea id="ed" spellcheck="false" placeholder="Write markdown‚Ä¶"></textarea>
  <div id="pv"></div>

  <div id="bar">
    <span id="tagdot" title="Right-click to cycle tag"></span>
    <input id="name" placeholder="Node name" />
    <button id="hlNew" class="btn" title="Insert highlight block">üìå</button>
    <button id="imgToggle" class="btn" title="Collapse images in editor">üóúÔ∏è</button>

    <button id="mode" class="btn" title="Preview/Edit toggle">üëÅÔ∏è</button>
    <button id="copyLink" class="btn" title="Copy link / Shift: iframe / Alt/Ctrl: editor">üîó</button>

    <button id="pasteTree" class="btn" title="Paste subtree as child">üì•</button>
    <span id="st">Ready</span>
  </div>
</div>

<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="https://cdn.jsdelivr.net/npm/marked@12/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>

<script>
  /* =================== CONFIG =================== */
  const SUPABASE_URL = "https://gjdyushogvhuootdiwxz.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdqZHl1c2hvZ3ZodW9vdGRpd3h6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY4NTE3NTMsImV4cCI6MjA3MjQyNzc1M30.52heLq-Ic5DIXCZV0tCiv_VhubkY2-v3arq7InoI-sE";
  const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  /* =================== DOM HOOKS =================== */
  const ed = document.getElementById('ed');
  const pv = document.getElementById('pv');
  const bar = document.getElementById('bar');
  const st = document.getElementById('st');
  const nameEl = document.getElementById('name');
  const btnMode = document.getElementById('mode');
  const btnPasteTree = document.getElementById('pasteTree');
  const tagDot = document.getElementById('tagdot');

  /* =================== STATE =================== */
  let node = null;
  let graphId = null;
  let mode = 'prev';              // default to Preview
  let saveTimer = null;

  /* =================== HL REGEX (declare early) =================== */
  const HL_BLOCK_RE = /\{\{HL:(\d+)(?:\|up=(\d+))?\}\}([\s\S]*?)\{\{\/HL\}\}/g;
  const HL_REF_RE = /<<HL:(\d+)>>/g;

  /* =================== SANITIZE: allow data:image/* =================== */
  DOMPurify.addHook('uponSanitizeAttribute', (node, data) => {
    if (
      node && node.nodeName === 'IMG' &&
      data && data.attrName === 'src' &&
      typeof data.attrValue === 'string' &&
      data.attrValue.startsWith('data:image/')
    ) {data.keepAttr = true;}
  });
  const PURIFY_CFG = {
    ALLOWED_URI_REGEXP: /^(?:https?|mailto|tel|data:image\/[a-zA-Z0-9.+-]+;base64,)/i
  };

  /* =================== TAG COLORS =================== */
  const TAGS = [null, "#8b5cf6", "#f59e0b", "#10b981", "#06b6d4", "#ef4444", "#f472b6", "#94a3b8"];

  /* =================== UTIL =================== */
  function msg(t) {st.textContent = t;}
  function qs(k) {return new URLSearchParams(location.search).get(k);}

  function paintDot() {
    const c = TAGS[(node?.tag || 0) % TAGS.length];
    tagDot.style.background = c ? c : "transparent";
    tagDot.style.borderColor = c ? c : "#e5e7eb";
  }

  /* Right-click bottom bar to cycle tag */
  bar.addEventListener('contextmenu', async (e) => {
    e.preventDefault();
    if (!node) return;
    const next = ((node?.tag || 0) + 1) % TAGS.length;
    node.tag = next; paintDot();
    msg('Saving‚Ä¶');
    await sb.from('nodes').update({tag: next}).eq('id', node.id);
    msg('Saved');
  });

  /* =================== LOAD =================== */
  async function load() {
    const id = qs('id');
    if (!id) {msg('No node id'); return;}
    const {data: n, error} = await sb.from('nodes').select('*').eq('id', id).single();
    if (error || !n) {msg('Node not found'); return;}
    node = n; graphId = n.graph_id;
    nameEl.value = n.label || '';
    ed.value = n.note_md || '';
    paintDot();
    msg('Ready');
    if (mode === 'prev') await renderPreview();
  }

  /* =================== SAVE (debounced) =================== */
  function queueSave(kind) {
    clearTimeout(saveTimer);
    st.textContent = 'Saving‚Ä¶';
    saveTimer = setTimeout(async () => {
      if (!node) return;
      const update = {};
      if (kind === 'name') {update.label = nameEl.value; node.label = update.label;}
      if (kind === 'doc') {
        const raw = ed.value;
        const expanded = expandText(raw);       // expands {{IMG:‚Ä¶}} ‚Üí real data:image/‚Ä¶
        await syncHighlights(expanded);         // upsert child‚Äôs highlight rows
        update.note_md = expanded;              // store expanded in DB
        node.note_md = expanded;
      }

      await sb.from('nodes').update(update).eq('id', node.id);
      st.textContent = 'Saved';
      if (mode === 'prev') await renderPreview();
    }, 450);
  }

  /* =================== HL helpers =================== */
  function stripHLBlocks(md) {
    // keep inner content, remove {{HL:‚Ä¶}} wrappers
    return md.replace(HL_BLOCK_RE, (m, key, up, content) => (content || '').trim());
  }


  async function copyText(text) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch {
      try {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.opacity = '0';
        document.body.appendChild(ta);
        ta.focus(); ta.select();
        const ok = document.execCommand('copy');
        document.body.removeChild(ta);
        return ok;
      } catch {return false;}
    }
  }


  async function expandHighlightRefs(markdown) {
    // 1) Expand editor-level tokens (e.g., {{IMG:..}}) up front
    const mdExpanded = expandText(markdown || '');

    // 2) Collect referenced keys in this doc
    const need = new Set();
    mdExpanded.replace(HL_REF_RE, (_, k) => {
      const n = parseInt(k, 10);
      if (Number.isFinite(n)) need.add(n);
      return '';
    });
    if (need.size === 0 || !node?.id) return mdExpanded;

    // 3) Parse THIS node‚Äôs HL blocks from the expanded text (so images are concrete)
    const localBlocks = extractHighlights(mdExpanded);
    const localMap = new Map(localBlocks.map(b => [b.key, {content: b.content, dist: 0}]));

    // 4) Fetch graph edges and highlight rows (descendants) for the remaining keys
    const [edgesRes, hsRes] = await Promise.all([
      sb.from('edges').select('source,target').eq('graph_id', graphId),
      sb.from('highlights')
        .select('node_id,key_int,max_up,content')
        .eq('graph_id', graphId)
        .in('key_int', Array.from(need))
    ]);
    const edges = edgesRes.data || [];
    const hs = hsRes.data || [];

    // 5) Downward adjacency + BFS from current node
    const down = new Map();
    for (const e of edges) {
      if (!down.has(e.source)) down.set(e.source, []);
      down.get(e.source).push(e.target);
    }
    const dist = new Map([[node.id, 0]]);
    const q = [node.id];
    while (q.length) {
      const u = q.shift();
      for (const v of (down.get(u) || [])) {
        if (!dist.has(v)) {
          dist.set(v, dist.get(u) + 1);
          q.push(v);
        }
      }
    }

    // 6) Choose best descendant highlight per key (respect up=)
    const best = new Map(); // key -> {content, dist}
    for (const h of hs) {
      const d = dist.get(h.node_id);
      if (d == null) continue;
      const maxUp = h.max_up || 1;
      if (d <= maxUp) {
        const cur = best.get(h.key_int);
        if (!cur || d < cur.dist) best.set(h.key_int, {content: h.content, dist: d});
      }
    }

    // 7) Substitute, preferring LOCAL content first
    return mdExpanded.replace(HL_REF_RE, (m, k) => {
      const key = parseInt(k, 10);
      const local = localMap.get(key);
      if (local) return local.content;          // same-node pin ‚Üí use expanded content
      const desc = best.get(key);
      return desc ? desc.content : m;           // otherwise best descendant or leave token
    });
  }


  /* =================== PREVIEW =================== */
  async function renderPreview() {
    const md0 = expandText(ed.value || '');     // expands images if compact
    const md1 = await expandHighlightRefs(md0);
    const md2 = stripHLBlocks(md1);
    pv.innerHTML = DOMPurify.sanitize(marked.parse(md2 || ''), PURIFY_CFG);
  }


  /* =================== PASTE SUBTREE =================== */
  async function insertChildrenRec(parentId, arr) {
    for (let i = 0; i < arr.length; i++) {
      const ch = arr[i] || {};
      const {data: nodeRow} = await sb.from('nodes')
        .insert({
          graph_id: graphId,
          label: ch.label || '',
          note_md: ch.note_md || '',
          tag: ch.tag || 0,
          sibling_order: i
        })
        .select().single();
      await sb.from('edges').insert({graph_id: graphId, source: parentId, target: nodeRow.id});
      if (Array.isArray(ch.children) && ch.children.length) {
        await insertChildrenRec(nodeRow.id, ch.children);
      }
    }
  }

  function absUrl(path) {return new URL(path, location.href).toString();}
  function nodeViewUrl() {return absUrl('toolbar.html?id=' + node.id);}
  function nodeEditUrl() {return absUrl('toolbar.html?id=' + node.id);}
  function nodeIframe() {
    const src = nodeViewUrl();
    return `<iframe src="${src}" width="640" height="480" frameborder="0" allow="clipboard-read; clipboard-write"></iframe>`;
  }

  const btnCopyLink = document.getElementById('copyLink');
  btnCopyLink.onclick = async (ev) => {
    if (!node) {alert('No node loaded'); return;}
    let payload, label;
    if (ev.shiftKey) {
      payload = nodeIframe(); label = 'iframe';
    } else if (ev.altKey || ev.ctrlKey || ev.metaKey) {
      payload = nodeEditUrl(); label = 'editor link';
    } else {
      payload = nodeViewUrl(); label = 'viewer link';
    }
    const ok = await copyText(payload);
    msg(ok ? `Copied ${label}` : 'Copy failed');
  };


  async function insertSubtreeAsChild(parentId, tree) {
    // figure current children count to append at end
    const {data: edges = []} = await sb.from('edges').select('source,target').eq('graph_id', graphId);
    const order = edges.filter(e => e.source === parentId).length;

    const {data: rootRow} = await sb.from('nodes')
      .insert({
        graph_id: graphId,
        label: tree.label || '',
        note_md: tree.note_md || '',
        tag: tree.tag || 0,
        sibling_order: order
      })
      .select().single();

    await sb.from('edges').insert({graph_id: graphId, source: parentId, target: rootRow.id});

    if (Array.isArray(tree.children) && tree.children.length) {
      await insertChildrenRec(rootRow.id, tree.children);
    }
    return rootRow.id;
  }

  async function readClipboardText() {
    try {return await navigator.clipboard.readText();}
    catch {
      // Fallback prompt (user can paste into the prompt)
      const t = prompt('Paste subtree JSON here:');
      return t || '';
    }
  }

  btnPasteTree.onclick = async () => {
    if (!node) {alert('No node loaded'); return;}
    msg('Reading clipboard‚Ä¶');
    const text = await readClipboardText();
    if (!text) {msg('Ready'); return;}

    let data;
    try {data = JSON.parse(text);}
    catch {alert('Clipboard is not valid JSON'); msg('Ready'); return;}

    const tree = (data && data.tree) ? data.tree : data;
    if (!tree || typeof tree !== 'object' || !('label' in tree)) {
      alert('Clipboard does not contain a Radial subtree'); msg('Ready'); return;
    }

    try {
      msg('Saving‚Ä¶');
      await insertSubtreeAsChild(node.id, tree);
      msg('Subtree pasted');
    } catch (e) {
      console.error(e);
      alert('Paste failed: ' + (e?.message || e));
      msg('Ready');
    }
  };

  /* =================== NAME / DOC EVENTS =================== */
  nameEl.addEventListener('input', () => queueSave('name'));
  ed.addEventListener('input', () => queueSave('doc'));

  /* Preview/Edit toggle */
  function setMode(m) {
    mode = m;
    if (mode === 'prev') {ed.style.display = 'none'; pv.style.display = 'block'; btnMode.textContent = '‚úèÔ∏è'; btnMode.title = 'Edit';}
    else {ed.style.display = 'block'; pv.style.display = 'none'; btnMode.textContent = 'üëÅÔ∏è'; btnMode.title = 'Preview';}
  }
  btnMode.onclick = async () => {
    if (mode === 'prev') {setMode('edit');}
    else {setMode('prev'); await renderPreview();}
  };

  /* =================== IMAGE PASTE (optional, data URL) =================== */
  window.addEventListener('paste', (e) => {
    const items = e.clipboardData?.items || [];
    for (const it of items) {
      if (it.type && it.type.startsWith('image/')) {
        e.preventDefault();
        const file = it.getAsFile(); if (!file) return;
        const r = new FileReader();
        r.onload = () => {
          const dataUrl = String(r.result || "");
          const s = ed.selectionStart, t = ed.selectionEnd, v = ed.value;
          let snippet = `\n![pasted](${dataUrl})\n`;
          if (compact) {
            // Put it in the map and token immediately
            const id = `img${Object.keys(imgMap).length + 1}`;
            imgMap[id] = {alt: 'pasted', url: dataUrl};
            snippet = `\n{{IMG:${id}}}\n`;
          }
          ed.value = v.slice(0, s) + snippet + v.slice(t);
          ed.selectionStart = ed.selectionEnd = s + snippet.length;
          ed.focus();
          queueSave('doc');
          if (mode === 'prev') renderPreview();
        };
        r.readAsDataURL(file);
        return;
      }
    }
  });

  /* ---------- Collapse/expand data-URI images in editor ---------- */
  let compact = false;        // editor shows collapsed image tokens when true
  let imgMap = {};            // id -> {alt, url}

  /* Find all data-URI images and build a map; return collapsed text */
  function collapseImages(text) {
    imgMap = {};
    let idx = 1;
    const re = /!\[([^\]]*)\]\((data:image\/[a-zA-Z0-9.+-]+;base64,[^)]+)\)/g;
    return text.replace(re, (_m, alt, url) => {
      const id = `img${idx++}`;
      imgMap[id] = {alt: alt || 'pasted', url};
      return `{{IMG:${id}}}`;
    });
  }

  /* Expand {{IMG:id}} tokens back to full data-URI images using the current imgMap */
  function expandImages(text) {
    return text.replace(/\{\{IMG:([a-zA-Z0-9_-]+)\}\}/g, (_m, id) => {
      const rec = imgMap[id];
      if (!rec) return _m; // token unknown -> leave as-is
      return `![${rec.alt}](${rec.url})`;
    });
  }

  /* Expand if compact; otherwise pass-through */
  function expandText(text) {return compact ? expandImages(text) : text;}

  /* ---------- Insert at caret helper ---------- */
  function insertAtSelection(textarea, snippet) {
    const s = textarea.selectionStart, e = textarea.selectionEnd, v = textarea.value;
    textarea.value = v.slice(0, s) + snippet + v.slice(e);
    const p = s + snippet.length;
    textarea.selectionStart = textarea.selectionEnd = p;
    textarea.focus();
  }

  /* ---------- Highlights: auto key ---------- */
  async function nextHLKey() {
    const {data: rows = []} = await sb
      .from('highlights')
      .select('key_int')
      .eq('graph_id', graphId)
      .order('key_int', {ascending: false})
      .limit(1);
    const maxK = rows.length ? (rows[0].key_int || 0) : 0;
    return maxK + 1;
  }

  /* Minimal HL sync so <<HL:n>> resolves in preview */
  // keep your HL_BLOCK_RE / HL_REF_RE up top

  function extractHighlights(md) {
    const blocks = [];
    let m;
    while ((m = HL_BLOCK_RE.exec(md))) {
      blocks.push({
        key: parseInt(m[1], 10),
        up: m[2] ? parseInt(m[2], 10) : 1,
        content: (m[3] || '').trim()
      });
    }
    return blocks;
  }

  async function syncHighlights(markdown) {
    if (!node) return;
    const blocks = extractHighlights(markdown);

    // existing rows for THIS node
    const {data: exist = []} = await sb
      .from('highlights')
      .select('id,key_int,max_up,content')
      .eq('graph_id', graphId)
      .eq('node_id', node.id);

    const existMap = new Map(exist.map(h => [h.key_int, h]));
    const seen = new Set();

    for (const b of blocks) {
      seen.add(b.key);
      const prev = existMap.get(b.key);
      if (!prev) {
        await sb.from('highlights').insert({
          graph_id: graphId, node_id: node.id,
          key_int: b.key, max_up: b.up, content: b.content
        });
      } else if (prev.max_up !== b.up || prev.content !== b.content) {
        await sb.from('highlights')
          .update({max_up: b.up, content: b.content})
          .eq('id', prev.id);
      }
    }

    // delete highlights removed from this node's markdown
    for (const [key, row] of existMap.entries()) {
      if (!seen.has(key)) await sb.from('highlights').delete().eq('id', row.id);
    }
  }

  async function ancestorsWithin(nodeId, maxDepth) {
    const {data: edges = []} = await sb
      .from('edges').select('source,target').eq('graph_id', graphId);

    const parentOf = new Map(edges.map(e => [e.target, e.source]));
    const out = [];
    let cur = nodeId, d = 0;
    while (d < maxDepth) {
      const p = parentOf.get(cur);
      if (!p) break;
      out.push(p);
      cur = p;
      d++;
    }
    return out; // [immediateParent, grandParent, ...]
  }

  function ensureNewlineEnd(s) {return s && !s.endsWith('\n') ? s + '\n' : (s || '');}

  async function ensureHLReceiversForPin(key, up) {
    const ancestors = await ancestorsWithin(node.id, up);
    const tokenRe = new RegExp(`<<HL:${key}>>`);

    for (const aid of ancestors) {
      const {data: parent} = await sb.from('nodes')
        .select('id,note_md').eq('id', aid).single();

      if (!parent) continue;
      const md = parent.note_md || '';
      if (tokenRe.test(md)) continue; // already has receiver

      const updated = ensureNewlineEnd(md) + `<<HL:${key}>>\n`;
      await sb.from('nodes').update({note_md: updated}).eq('id', aid);
    }
  }



  const btnHL = document.getElementById('hlNew');
  const btnImgTog = document.getElementById('imgToggle');

  /* üìå Insert a new HL block with auto-assigned number (up=99) */
  btnHL.onclick = async () => {
    if (!node) return;
    const k = await nextHLKey();
    const s = ed.selectionStart, e = ed.selectionEnd;
    const sel = ed.value.slice(s, e);
    const body = sel && sel.trim().length ? sel : 'SOME MARKDOWN WOO üê∏üê∏';
    const upVal = 99; // default reach

    const block = `\n{{HL:${k}|up=${upVal}}}\n${body}\n{{/HL}}\n`;
    insertAtSelection(ed, block);

    // Save immediately and sync HL rows for *this* node
    const expanded = expandText(ed.value);         // expand {{IMG:‚Ä¶}} if compact
    await sb.from('nodes').update({note_md: expanded}).eq('id', node.id);
    await syncHighlights(expanded);

    // Now auto-create receivers in ancestors
    await ensureHLReceiversForPin(k, upVal);

    msg(`HL #${k} pinned & linked`);
    if (mode === 'prev') await renderPreview();
  };


  /* üóúÔ∏è Collapse/expand images in the editor */
  btnImgTog.onclick = async () => {
    if (compact) {
      // expand back
      ed.value = expandImages(ed.value);
      compact = false;
      btnImgTog.textContent = 'üóúÔ∏è';
      btnImgTog.title = 'Collapse images in editor';
    } else {
      // collapse current data-URI images to tokens
      ed.value = collapseImages(ed.value);
      compact = true;
      btnImgTog.textContent = 'üß©';
      btnImgTog.title = 'Expand images in editor';
    }
    queueSave('doc');                 // save expanded form (see below)
    if (mode === 'prev') await renderPreview();
  };






  /* =================== BOOT =================== */
  (async function () {
    setMode('prev');         // default to Preview on open
    await load();            // fetch node & populate
  })();
</script>
