<!doctype html>
<meta charset="utf-8" />
<title>Toolbar ‚Äî minimal markdown (data-URI + edit compact)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,
  body {
    height: 100%;
    margin: 0;
    font: 14px system-ui, -apple-system, Segoe UI, Roboto;
    background: #fff
  }

  #wrap {
    height: 100%;
    display: flex;
    flex-direction: column
  }

  #editor {
    flex: 1;
    display: block;
    width: 100%;
    height: 100%;
    resize: none;
    border: 0;
    outline: 0;
    padding: 12px;
    font: 13px ui-monospace, Menlo, Consolas
  }

  #preview {
    flex: 1;
    display: none;
    padding: 12px;
    overflow: auto
  }

  #bar {
    display: flex;
    gap: 8px;
    align-items: center;
    padding: 8px;
    border-top: 1px solid #eef2f7;
    background: #fafafa
  }

  #name {
    flex: 1;
    min-width: 120px;
    padding: 4px 6px;
    border: 1px solid #e5e7eb;
    border-radius: 8px
  }

  button {
    padding: 4px 6px;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    background: #fff;
    cursor: pointer
  }

  button.active {
    background: #eef2ff;
    border-color: #c7d2fe
  }

  .danger {
    border-color: #fecaca;
    background: #fff5f5
  }

  .muted {
    font-size: 12px;
    color: #6b7280;
    margin-left: auto
  }

  img {
    max-width: 100%;
    height: auto
  }
</style>

<div id="wrap">
  <textarea id="editor" placeholder="Markdown‚Ä¶"></textarea>
  <div id="preview"></div>

  <div id="bar">
    <span id="tagdot" title="Right-click to cycle tag"
      style="width:14px;height:14px;border-radius:9999px;border:1px solid #e5e7eb;display:inline-block"></span>


    <input id="name" placeholder="Node name" />
    <button id="add" title="Add child">‚ûï</button>
    <button id="insHL" title="Insert HL token">üîÅ</button>
    <button id="copy" title="Copy embed link">üîó</button>
    <button id="compact" title="Compact data-URI images in editor">üóúÔ∏è</button>



    <button id="mode" title="Preview">üëÅÔ∏è</button>
    <button id="left" title="Move left">‚¨ÖÔ∏è</button>
    <button id="right" title="Move right">‚û°Ô∏è</button>



    <button id="del" class="danger" title="Delete subtree">üóëÔ∏è</button>
    <span id="st" class="muted">Ready</span>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify@3/dist/purify.min.js"></script>
<script>
  /* ---- config ---- */
  const SUPABASE_URL = "https://gjdyushogvhuootdiwxz.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdqZHl1c2hvZ3ZodW9vdGRpd3h6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY4NTE3NTMsImV4cCI6MjA3MjQyNzc1M30.52heLq-Ic5DIXCZV0tCiv_VhubkY2-v3arq7InoI-sE";
  const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  const TAGS = [
    null, "#8b5cf6", "#f59e0b", "#10b981", "#06b6d4",
    "#ef4444", "#f472b6", "#94a3b8"
  ];


  /* ---- dom ---- */
  const ed = document.getElementById('editor');
  const pv = document.getElementById('preview');
  const nameEl = document.getElementById('name');
  const st = document.getElementById('st');
  const btnLeft = document.getElementById('left');
  const btnRight = document.getElementById('right');
  const btnAdd = document.getElementById('add');
  const btnMode = document.getElementById('mode');
  const btnCopy = document.getElementById('copy');
  const btnDel = document.getElementById('del');
  const btnCompact = document.getElementById('compact');

  /* ---- state ---- */
  const qs = new URLSearchParams(location.search);
  const nodeId = qs.get('id');
  let node = null, graphId = null, saveTimer = null, mode = 'edit';
  let compact = false;

  /* Data-URI compaction map:
     we replace (in editor view only) data-URI with {{IMG:token}}; on save/preview we expand back. */
  let imgSeq = 1;
  const tokenFor = new Map(); // dataUri -> token
  const dataFor = new Map(); // token   -> dataUri

  const dataUriRe = /!\[[^\]]*\]\(\s*(data:image\/[a-zA-Z0-9.+-]+;base64,[^)]+?)\s*\)/g;
  const tokenRe = /\{\{IMG:([a-zA-Z0-9_-]+)\}\}/g;

  function indexImages(markdown) {
    (markdown.match(dataUriRe) || []).forEach(m => {
      const uri = m.replace(dataUriRe, '$1');
      if (!tokenFor.has(uri)) {
        const tok = 'img' + (imgSeq++);
        tokenFor.set(uri, tok);
        dataFor.set(tok, uri);
      }
    });
  }
  function collapseText(markdown) {
    return markdown.replace(dataUriRe, (full, uri) => {
      const tok = tokenFor.get(uri) || (() => {const t = 'img' + (imgSeq++); tokenFor.set(uri, t); dataFor.set(t, uri); return t;})();
      return full.replace(uri, `{{IMG:${tok}}}`);
    });
  }
  function expandText(markdown) {
    return markdown.replace(tokenRe, (full, tok) => dataFor.get(tok) || full);
  }

  /* ---- marked: default rendering (data-URIs show inline) ---- */
  async function expandHighlightRefs(markdown) {
    // Collect the keys present as <<HL:123>>
    const keys = [];
    markdown.replace(HL_REF_RE, (_, k) => {keys.push(parseInt(k, 10)); return '';});
    if (!keys.length) return markdown;

    // Load edges + highlights for these keys
    const [{data: edges = []}, {data: hs = []}] = await Promise.all([
      sb.from('edges').select('source,target').eq('graph_id', graphId),
      sb.from('highlights').select('node_id,key_int,max_up,content').eq('graph_id', graphId).in('key_int', keys)
    ]);

    // Build adjacency for downward BFS from current node
    const down = new Map();
    edges.forEach(e => {(down.get(e.source) || down.set(e.source, [])).get(e.source);});
    // Fix: the above line just ensures map key; now push properly
    edges.forEach(e => {
      if (!down.has(e.source)) down.set(e.source, []);
      down.get(e.source).push(e.target);
    });

    // Distance from this node to descendants
    const dist = new Map([[node.id, 0]]);
    const q = [node.id];
    while (q.length) {
      const u = q.shift();
      for (const v of (down.get(u) || [])) {
        if (!dist.has(v)) {
          dist.set(v, dist.get(u) + 1);
          q.push(v);
        }
      }
    }

    // Pick nearest valid highlight per key (respecting max_up)
    const best = new Map(); // key -> content
    hs.forEach(h => {
      const d = dist.get(h.node_id);
      if (d == null) return;
      if (d <= (h.max_up || 1)) {
        const cur = best.get(h.key_int);
        if (!cur || d < cur.dist) best.set(h.key_int, {content: h.content, dist: d});
      }
    });

    // Replace tokens
    return markdown.replace(HL_REF_RE, (m, k) => {
      const b = best.get(parseInt(k, 10));
      return b ? b.content : m; // leave token if nothing valid
    });
  }

  async function renderPreview() {
    // Expand compact IMG tokens and HL refs before parsing
    const md0 = compact ? expandText(ed.value) : ed.value;
    const md1 = await expandHighlightRefs(md0);
    pv.innerHTML = DOMPurify.sanitize(marked.parse(md1 || ''));
  }

  // Add to HTML bar: <button id="insHL" title="Insert HL token">üîÅ</button>
  const btnInsHL = document.getElementById('insHL');
  btnInsHL.onclick = () => {
    const k = prompt('Highlight number to reference? (e.g., 123)');
    if (!k) return;
    const t = `<<HL:${parseInt(k, 10)}>>`;
    const s = ed.selectionStart, e = ed.selectionEnd, v = ed.value;
    ed.value = v.slice(0, s) + t + v.slice(e);
    ed.selectionStart = ed.selectionEnd = s + t.length;
    ed.focus();
    queueSave('doc');
  };



  /* ---- helpers ---- */
  /* ======= Highlight plumbing ======= */
  /* Syntax:
     {{HL:123|up=2}}
     ... any markdown ...
     {{/HL}}
     - 123 is the highlight number (required, integer)
     - up=2 is optional, defaults to 1
  */
  const HL_BLOCK_RE = /\{\{HL:(\d+)(?:\|up=(\d+))?\}\}([\s\S]*?)\{\{\/HL\}\}/g;
  const HL_REF_RE = /<<HL:(\d+)>>/g;

  function extractHighlights(md) {
    const out = [];
    let m;
    while ((m = HL_BLOCK_RE.exec(md))) {
      const key = parseInt(m[1], 10);
      const up = m[2] ? parseInt(m[2], 10) : 1;
      const content = (m[3] || '').trim();
      if (!Number.isFinite(key) || key < 0) continue;
      out.push({key, up, content});
    }
    return out;
  }





  function msg(t) {st.textContent = t; if (t !== 'Saving‚Ä¶') setTimeout(() => {if (st.textContent === t) st.textContent = 'Ready';}, 1000);}
  function setMode(m) {
    mode = m;
    if (m === 'edit') {ed.style.display = 'block'; pv.style.display = 'none'; btnMode.textContent = 'üëÅÔ∏è'; btnMode.title = 'Preview';}
    else {renderPreview(); ed.style.display = 'none'; pv.style.display = 'block'; btnMode.textContent = '‚úèÔ∏è'; btnMode.title = 'Edit';}
  }
  function kidsOf(id, edges) {return edges.filter(e => e.source === id).map(e => e.target);}
  function queueSave(kind) {
    st.textContent = 'Saving‚Ä¶';
    clearTimeout(saveTimer);
    saveTimer = setTimeout(async () => {
      const update = {};
      if (kind === 'doc') {
        update.note_md = compact ? expandText(ed.value) : ed.value; // never save compacted tokens
      }
      await sb.from('nodes').update(update).eq('id', node.id);
      await syncHighlights(ed.value);  // <-- add this line

      if (kind === 'name') {update.label = nameEl.value;}
      await sb.from('nodes').update(update).eq('id', node.id);
      msg('Saved');
      if (mode === 'prev') renderPreview();
    }, 200);
  }

  function paintDot() {
    const c = TAGS[(node?.tag || 0) % TAGS.length];
    const dot = document.getElementById('tagdot');
    dot.style.background = c ? c : "transparent";
    dot.style.borderColor = c ? c : "#e5e7eb";
  }


  /* ---- load node ---- */
  async function load() {
    const {data: n, error} = await sb.from('nodes').select('*').eq('id', nodeId).single();
    if (error) {st.textContent = 'Load error'; return;}
    node = n; graphId = n.graph_id;
    nameEl.value = n.label || '';
    ed.value = n.note_md || '';
    paintDot();                      // NEW
    tokenFor.clear(); dataFor.clear(); imgSeq = 1;
    indexImages(ed.value);
    msg('Ready');
  }

  /* ---- editor + name autosave ---- */
  ed.addEventListener('input', () => {indexImages(ed.value); queueSave('doc');});
  nameEl.addEventListener('input', () => queueSave('name'));

  /* ---- paste: convert clipboard images to data-URI ---- */
  window.addEventListener('paste', (e) => {
    const items = e.clipboardData?.items || [];
    for (const it of items) {
      if (it.type && it.type.startsWith('image/')) {
        e.preventDefault();
        const file = it.getAsFile(); if (!file) return;
        const r = new FileReader();
        r.onload = () => {
          const dataUrl = String(r.result || "");
          // insert full data-URI markdown at caret
          const start = ed.selectionStart, end = ed.selectionEnd, v = ed.value;
          const snippet = `\n![pasted](${dataUrl})\n`;
          ed.value = v.slice(0, start) + snippet + v.slice(end);
          // index & optionally compact that insertion
          indexImages(ed.value);
          if (compact) {ed.value = collapseText(ed.value);}
          queueSave('doc');
          if (mode === 'prev') renderPreview();
        };
        r.readAsDataURL(file);
        return;
      }
    }
    // allow normal text paste otherwise
  });

  async function syncHighlights(markdown) {
    // Find current blocks in editor (expand any compact IMG tokens first)
    const expandedMd = compact ? expandText(markdown) : markdown;
    const blocks = extractHighlights(expandedMd);

    // Existing highlights for this node
    const {data: existing = []} = await sb
      .from('highlights')
      .select('id,key_int,max_up,content')
      .eq('graph_id', graphId)
      .eq('node_id', node.id);

    const extByKey = new Map(existing.map(h => [h.key_int, h]));

    // Upsert new/changed blocks; collect "first-time" keys
    const firstTimeKeys = [];
    for (const b of blocks) {
      const prev = extByKey.get(b.key);
      if (!prev) {
        firstTimeKeys.push(b.key);
        await sb.from('highlights').insert({
          graph_id: graphId, node_id: node.id,
          key_int: b.key, max_up: b.up, content: b.content
        });
      } else {
        if (prev.max_up !== b.up || prev.content !== b.content) {
          await sb.from('highlights').update({
            max_up: b.up, content: b.content, updated_at: new Date().toISOString()
          }).eq('id', prev.id);
        }
        extByKey.delete(b.key);
      }
    }

    // Delete removed blocks
    for (const [k, h] of extByKey) {
      await sb.from('highlights').delete().eq('id', h.id);
    }

    // For first-time keys, offer to auto-insert tokens into ancestors up to max_up
    if (firstTimeKeys.length) {
      // Load edges once
      const {data: edges = []} = await sb.from('edges').select('source,target').eq('graph_id', graphId);
      const parentMap = new Map();  // child -> parent
      edges.forEach(e => parentMap.set(e.target, e.source || null));

      // Walk up ancestors with distance
      function ancestorsUpTo(startId, up) {
        const res = [];
        let cur = startId, d = 0;
        while (d < up) {
          const p = parentMap.get(cur);
          if (!p) break;
          d += 1;
          res.push({id: p, dist: d});
          cur = p;
        }
        return res;
      }

      // For each first-time key: find its block to know max_up
      for (const k of firstTimeKeys) {
        const blk = blocks.find(b => b.key === k);
        if (!blk) continue;
        const ancestors = ancestorsUpTo(node.id, blk.up);

        // Ask per parent whether to insert a token if not already present
        for (const {id: pid} of ancestors) {
          const {data: pnode, error: pnerr} = await sb.from('nodes').select('*').eq('id', pid).single();
          if (pnerr || !pnode) continue;
          const hasRef = (pnode.note_md || '').includes(`<<HL:${k}>>`);
          if (!hasRef) {
            const ok = confirm(`Add highlight <<HL:${k}>> to parent "${pnode.label || '(untitled)'}"?`);
            if (ok) {
              const updated = (pnode.note_md || '') + `\n\n<<HL:${k}>>\n`;
              await sb.from('nodes').update({note_md: updated}).eq('id', pid);
            }
          }
        }
      }
    }
  }


  /* ---- compact toggle (editor-only) ---- */
  btnCompact.onclick = () => {
    compact = !compact;
    btnCompact.classList.toggle('active', compact);
    if (compact) {
      indexImages(ed.value);
      ed.value = collapseText(ed.value);
    } else {
      ed.value = expandText(ed.value);
    }
    // do not save just for toggling visual mode
    if (mode === 'prev') renderPreview();
  };

  /* ---- reorder (visual LEFT = later; RIGHT = earlier) ---- */
  async function siblings() {
    const {data: edges = []} = await sb.from('edges').select('*').eq('graph_id', graphId);
    const p = edges.find(x => x.target === node.id)?.source || null;
    const ks = p ? kidsOf(p, edges) : [node.id];
    const {data: nodes = []} = await sb.from('nodes').select('id,sibling_order').in('id', ks).order('sibling_order', {ascending: true});
    return {parent: p, order: nodes.map(r => r.id)};
  }
  btnLeft.onclick = async () => {
    const {order} = await siblings();
    const i = order.indexOf(node.id);
    if (i < 0 || i === order.length - 1) return;
    [order[i], order[i + 1]] = [order[i + 1], order[i]];
    for (let j = 0; j < order.length; j++) await sb.from('nodes').update({sibling_order: j}).eq('id', order[j]);
    msg('Moved left');
  };
  btnRight.onclick = async () => {
    const {order} = await siblings();
    const i = order.indexOf(node.id);
    if (i <= 0) return;
    [order[i], order[i - 1]] = [order[i - 1], order[i]];
    for (let j = 0; j < order.length; j++) await sb.from('nodes').update({sibling_order: j}).eq('id', order[j]);
    msg('Moved right');
  };

  /* ---- add child ---- */
  btnAdd.onclick = async () => {
    const title = prompt('Child title?'); if (title == null) return;
    const {data: edges = []} = await sb.from('edges').select('*').eq('graph_id', graphId);
    const order = kidsOf(node.id, edges);
    const {data: newN} = await sb.from('nodes')
      .insert({graph_id: graphId, label: title, sibling_order: order.length, note_md: ''})
      .select().single();
    await sb.from('edges').insert({graph_id: graphId, source: node.id, target: newN.id});
    msg('Child added');
  };

  /* ---- delete subtree (soft) ---- */
  btnDel.onclick = async () => {
    if (!confirm('Delete this node and all descendants?')) return;
    const {data: edges = []} = await sb.from('edges').select('*').eq('graph_id', graphId);
    const toDel = new Set([node.id]); const st = [node.id];
    while (st.length) {const u = st.pop(); edges.filter(x => x.source === u).forEach(x => {if (!toDel.has(x.target)) {toDel.add(x.target); st.push(x.target);} });}
    await sb.from('nodes').update({deleted_at: new Date().toISOString()}).in('id', [...toDel]);
    msg('Deleted');
  };
  const bar = document.getElementById('bar');
  bar.addEventListener('contextmenu', async (e) => {
    e.preventDefault();
    const next = ((node?.tag || 0) + 1) % TAGS.length;
    node.tag = next;
    paintDot();
    st.textContent = 'Saving‚Ä¶';
    await sb.from('nodes').update({tag: next}).eq('id', node.id);
    msg('Saved');
  });


  /* ---- preview toggle; copy embed; Esc closes in parent ---- */
  btnMode.onclick = async () => {
    if (mode === 'edit') {
      mode = 'prev'; ed.style.display = 'none'; pv.style.display = 'block';
      btnMode.textContent = '‚úèÔ∏è'; btnMode.title = 'Edit';
      await renderPreview();
    } else {
      mode = 'edit'; ed.style.display = 'block'; pv.style.display = 'none';
      btnMode.textContent = 'üëÅÔ∏è'; btnMode.title = 'Preview';
    }
  };

  btnCopy.onclick = async () => {
    const url = new URL(location.href); url.search = ''; url.searchParams.set('id', nodeId);
    await navigator.clipboard.writeText(url.toString()); msg('Link copied');
  };
  window.addEventListener('keydown', (e) => {if (e.key === 'Escape') {parent.postMessage('close-toolbar', '*');} });

  /* ---- boot ---- */
  setMode('edit'); load();
</script>
