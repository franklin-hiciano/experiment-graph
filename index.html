<!doctype html>
<meta charset="utf-8" />
<title>Layered Mindmap (Shift-drag to add child)</title>
<style>
  html,body,#app{height:100%;margin:0}
  #toolbar{padding:8px;border-bottom:1px solid #e5e7eb;font:14px system-ui;display:flex;gap:8px;align-items:center}
  #cy{height:calc(100% - 46px); user-select:none}
  button{padding:6px 10px;border:1px solid #d1d5db;border-radius:8px;background:#fff;cursor:pointer}
  #tooltip{
    position:absolute; pointer-events:none; background:#111827; color:#fff;
    padding:6px 8px; border-radius:8px; font:12px system-ui; max-width:280px;
    box-shadow:0 10px 20px rgba(0,0,0,.12); display:none; transform:translate(8px, -8px);
    white-space:pre-wrap; line-height:1.2;
  }
  #hint{color:#6b7280}
</style>

<div id="toolbar">
  <strong>Mindmap</strong>
  <span id="hint">Shift + drag from a node to empty space → create child at drop. Drag nodes horizontally to reorder; layers snap vertically. Double-click to edit. Hover for description.</span>
  <div style="margin-left:auto;display:flex;gap:8px">
    <button id="center">Center</button>
    <button id="export">Export JSON</button>
    <input id="importFile" type="file" accept="application/json">
  </div>
</div>
<div id="cy"></div>
<div id="tooltip"></div>

<script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
/*** ------- CONFIG ------- ***/
const SUPABASE_URL = "https://gjdyushogvhuootdiwxz.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdqZHl1c2hvZ3ZodW9vdGRpd3h6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY4NTE3NTMsImV4cCI6MjA3MjQyNzc1M30.52heLq-Ic5DIXCZV0tCiv_VhubkY2-v3arq7InoI-sE";
const GRAPH_ID = new URLSearchParams(location.search).get("graph") || "412dbeb5-7a9f-4bc7-a80a-8fd6e6d72465";

/* Layer + size tuning */
const LAYER_GAP = 70;   // vertical distance between layers
const FONT_BASE = 16;   // root font size
const FONT_STEP = 2;    // shrink per layer
const FONT_MIN  = 10;   // minimum font size
const WIDTH_MAX = 240;  // max node width (helps deeper nodes look smaller)

/*** ------- INIT ------- ***/
const { createClient } = supabase; 
const sb = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const nodesDS = new vis.DataSet([]);
const edgesDS = new vis.DataSet([]);

const net = new vis.Network(document.getElementById('cy'), { nodes: nodesDS, edges: edgesDS }, {
  physics: { enabled: false },
  interaction: { hover: true, multiselect: true, tooltipDelay: 120 },
  edges: {
    smooth: { type: 'cubicBezier', forceDirection: 'vertical', roundness: 0.2 },
    color: { opacity: 0.6 }
  },
  nodes: {
    shape: 'box',
    borderWidth: 1,
    margin: 8,
    widthConstraint: { maximum: WIDTH_MAX },
    color: { background: '#FFFFFF', border: '#9CA3AF', highlight: { background:'#EEF2FF', border:'#6366F1' } },
    font: { color: '#111827', face: 'system-ui', size: FONT_BASE, multi: 'html' }
  }
});

/*** ------- TOOLTIP ------- ***/
const tooltip = document.getElementById('tooltip');
function showTip(nodeId){
  const n = nodesDS.get(nodeId);
  const txt = (n?.description || '').trim();
  if(!txt){ tooltip.style.display='none'; return; }
  const posCanvas = net.getPositions([nodeId])[nodeId];
  const posDOM = net.canvasToDOM(posCanvas);
  tooltip.textContent = txt;
  tooltip.style.left = (posDOM.x + 12) + 'px';
  tooltip.style.top  = (posDOM.y - 12) + 'px';
  tooltip.style.display = 'block';
}
function hideTip(){ tooltip.style.display='none'; }

/*** ------- GRAPH UTILS ------- ***/
function computeRootId(){
  const all = nodesDS.getIds();
  if (all.length === 0) return null;
  const incoming = new Set(edgesDS.get().map(e => e.to));
  const roots = all.filter(id => !incoming.has(id));
  return roots[0] || all[0];
}
function buildDepths(){
  const root = computeRootId();
  const depth = {};
  if (!root) return { root:null, depth };

  const out = {};
  edgesDS.forEach(e => { (out[e.from] ||= []).push(e.to); });

  const q = [root]; depth[root] = 0;
  while (q.length){
    const u = q.shift();
    for (const v of (out[u]||[])){
      if (depth[v] == null){ depth[v] = depth[u] + 1; q.push(v); }
    }
  }
  nodesDS.forEach(n => { if (depth[n.id] == null) depth[n.id] = 0; });
  return { root, depth };
}
function applyLayersAndSizes(){
  const { depth } = buildDepths();
  const updates = [];
  nodesDS.forEach(n => {
    const d = depth[n.id] ?? 0;
    const y = d * LAYER_GAP;
    const f = Math.max(FONT_MIN, FONT_BASE - d * FONT_STEP);
    updates.push({ id: n.id, y, level: d, font: { size: f } });
  });
  nodesDS.update(updates);
  net.redraw();
}

/*** ------- DB HELPERS ------- ***/
async function insertNode({label, description, x, y}){
  const { data: row, error } = await sb.from('nodes')
    .insert({ graph_id: GRAPH_ID, label, description, x, y })
    .select().single();
  if(error) throw error;
  return row;
}
async function insertEdge(from, to){
  const { error } = await sb.from('edges').insert({ graph_id: GRAPH_ID, source: from, target: to });
  if (error) throw error;
}

/*** ------- CREATE-CHILD: SHIFT + DRAG FROM NODE ------- ***/
const container = document.getElementById('cy');
let createDrag = { active:false, from:null };

container.addEventListener('pointerdown', (e) => {
  if (!e.shiftKey) return;                       // only when Shift is held
  const rect = container.getBoundingClientRect();
  const domPt = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  const nodeId = net.getNodeAt(domPt);
  if (!nodeId) return;
  createDrag.active = true;
  createDrag.from = nodeId;
  e.preventDefault();                            // don’t start vis-network dragging
});

container.addEventListener('pointerup', async (e) => {
  if (!createDrag.active) return;
  const from = createDrag.from;
  createDrag = { active:false, from:null };

  const rect = container.getBoundingClientRect();
  const domPt = { x: e.clientX - rect.left, y: e.clientY - rect.top };

  // if we released over another node, do nothing (no child creation)
  const overNode = net.getNodeAt(domPt);
  if (overNode) return;

  // compute canvas coords and target layer
  const canvasPt = net.DOMtoCanvas(domPt);
  const parent = nodesDS.get(from);
  const parentDepth = parent?.level ?? 0;
  const d = parentDepth + 1;
  const y = d * LAYER_GAP;
  const x = canvasPt.x;

  // First node case (no root yet): if nothing exists, make this the root
  const root = computeRootId();
  if (!root){
    const label0 = prompt("Root title?");
    if (label0 == null) return;
    const desc0 = prompt("Description (optional):") || "";
    await insertNode({ label: label0, description: desc0, x, y: 0 });
    return;
  }

  // Create child node
  const label = prompt("Node title?");
  if (label == null) return;
  const description = prompt("Description (optional):") || "";
  const row = await insertNode({ label, description, x, y });
  await insertEdge(parent.id, row.id);

  // optimistic local update
  nodesDS.update({ id: row.id, label, description, x, y, level: d, font: { size: Math.max(FONT_MIN, FONT_BASE - d*FONT_STEP) } });
  edgesDS.update({ id: `tmp-${row.id}`, from: parent.id, to: row.id });
  applyLayersAndSizes();
});

/*** ------- OTHER INTERACTIONS ------- ***/
// Double-click node -> edit title/description
net.on('doubleClick', async (p) => {
  if (!p.nodes.length) return;
  const id = p.nodes[0];
  const n = nodesDS.get(id);
  const label = prompt("Edit title:", n.label ?? "") ?? n.label;
  const description = prompt("Edit description:", n.description ?? "") ?? n.description;
  const { error } = await sb.from('nodes').update({ label, description }).eq('id', id);
  if (error) alert(error.message);
});

// Normal drag -> reposition horizontally; snap Y to layer
net.on('dragEnd', async (p) => {
  for (const id of p.nodes) {
    const d = nodesDS.get(id)?.level ?? 0;
    const snapY = d * LAYER_GAP;
    const pos = net.getPositions([id])[id];
    nodesDS.update({ id, x: pos.x, y: snapY });
    await sb.from('nodes').update({ x: pos.x, y: snapY }).eq('id', id);
  }
  hideTip();
});

// Hover tooltip
net.on('hoverNode', (p) => showTip(p.node));
net.on('blurNode', hideTip);
net.on('zoom', hideTip);
net.on('dragStart', hideTip);

/*** ------- TOP BAR ------- ***/
document.getElementById('center').onclick = () => {
  net.fit({ animation: { duration: 300, easingFunction: 'easeInOutQuad' }});
};
document.getElementById('export').onclick = () => {
  const data = { nodes: nodesDS.get(), edges: edgesDS.get().map(e => ({...e, label: undefined})) };
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const a = Object.assign(document.createElement('a'), { href: URL.createObjectURL(blob), download: 'mindmap.json' });
  a.click();
};
document.getElementById('importFile').onchange = async (e) => {
  const file = e.target.files[0]; if (!file) return;
  const text = await file.text(); const json = JSON.parse(text);
  await sb.from('edges').delete().eq('graph_id', GRAPH_ID);
  await sb.from('nodes').delete().eq('graph_id', GRAPH_ID);
  for (const n of json.nodes) {
    await sb.from('nodes').insert({ id:n.id, graph_id:GRAPH_ID, label:n.label, description:n.description||'', x:n.x, y:n.y });
  }
  for (const ed of json.edges) {
    await sb.from('edges').insert({ id:ed.id, graph_id:GRAPH_ID, source:ed.from, target:ed.to });
  }
  applyLayersAndSizes();
};

/*** ------- LOAD + REALTIME ------- ***/
async function load() {
  const [{ data: ns }, { data: es }] = await Promise.all([
    sb.from('nodes').select("*").eq('graph_id', GRAPH_ID),
    sb.from('edges').select("*").eq('graph_id', GRAPH_ID),
  ]);
  nodesDS.clear(); edgesDS.clear();
  nodesDS.add((ns||[]).map(n => ({ id:n.id, label:n.label, description:n.description, x:n.x, y:n.y })));
  edgesDS.add((es||[]).map(e => ({ id:e.id, from:e.source, to:e.target })));
  applyLayersAndSizes();
}
load();

sb.channel('realtime-graph')
  .on('postgres_changes', { event:'*', schema:'public', table:'nodes', filter:`graph_id=eq.${GRAPH_ID}` }, (p) => {
    const r = p.new ?? p.old;
    if (p.eventType === 'INSERT' || p.eventType === 'UPDATE') {
      nodesDS.update({ id:r.id, label:r.label, description:r.description, x:r.x, y:r.y });
    }
    if (p.eventType === 'DELETE') nodesDS.remove(r.id);
    applyLayersAndSizes();
  })
  .on('postgres_changes', { event:'*', schema:'public', table:'edges', filter:`graph_id=eq.${GRAPH_ID}` }, (p) => {
    const r = p.new ?? p.old;
    if (p.eventType === 'INSERT' || p.eventType === 'UPDATE') {
      edgesDS.update({ id:r.id, from:r.source, to:r.target });
    }
    if (p.eventType === 'DELETE') edgesDS.remove(r.id);
    applyLayersAndSizes();
  })
  .subscribe();
</script>

