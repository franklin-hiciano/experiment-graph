<!doctype html>
<meta charset="utf-8" />
<title>Radial Mindmap — viewer (minimal)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,
  body {
    height: 100%;
    margin: 0;
    font: 14px system-ui, -apple-system, Segoe UI, Roboto
  }

  #wrap {
    position: relative;
    height: 100%
  }

  #svg {
    width: 100%;
    height: 100%;
    display: block;
    background: #fff
  }

  .edge {
    fill: none;
    stroke: #64748b;
    stroke-width: 1.25;
    opacity: .85;
    pointer-events: none
  }

  .band {
    vector-effect: non-scaling-stroke;
    pointer-events: none
  }

  .node {
    user-select: none;
    fill: #111827;
    cursor: pointer
  }

  .node.selected {
    font-weight: 700;
    fill: #1f2937
  }

  /* embedded toolbar panel (iframe only; no header/close) */
  #panel {
    position: absolute;
    top: 12px;
    right: 12px;
    width: 520px;
    height: 420px;
    background: #fff;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    box-shadow: 0 16px 36px rgba(0, 0, 0, .12);
    display: none;
    overflow: hidden;
    z-index: 10
  }

  #tools {
    width: 100%;
    height: 100%;
    border: 0
  }
</style>

<div id="wrap">
  <svg id="svg"></svg>
  <div id="panel"><iframe id="tools"></iframe></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
  /* ===== config ===== */
  const SUPABASE_URL = "https://gjdyushogvhuootdiwxz.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdqZHl1c2hvZ3ZodW9vdGRpd3h6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY4NTE3NTMsImV4cCI6MjA3MjQyNzc1M30.52heLq-Ic5DIXCZV0tCiv_VhubkY2-v3arq7InoI-sE";
  const GRAPH_ID = new URLSearchParams(location.search).get("graph") || "412dbeb5-7a9f-4bc7-a80a-8fd6e6d72465";
  const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  /* ===== layout constants ===== */
  const STEP = 120;
  const ANG0 = 0, ANG1 = Math.PI;
  const ROT = 0;   // rotate +90° so we’re the bottom semicircle
  const FONT = 16, SHRINK = 2, MINF = 10;

  /* ===== state ===== */
  const svg = d3.select("#svg");
  const g = svg.append("g"), gBands = g.append("g"), gEdges = g.append("g"), gNodes = g.append("g");
  let N = new Map(), E = [], depth = {}, angle = {}, pos = {}, sel = null;

  /* ===== helpers ===== */
  const byId = id => N.get(id);
  const kids = id => E.filter(e => e.source === id).map(e => e.target).filter(k => N.has(k));
  const rootId = () => {const inc = new Set(E.map(e => e.target)); for (const id of N.keys()) if (!inc.has(id)) return id; return [...N.keys()][0] || null;}
  const ring = d => d * STEP;

  /* ===== layout ===== */
  function buildDepths() {const r = rootId(); depth = {}; if (!r) return; depth[r] = 0; const q = [r]; while (q.length) {const u = q.shift(); for (const v of kids(u)) {depth[v] = (depth[u] || 0) + 1; q.push(v);} } N.forEach((_, id) => {if (depth[id] == null) depth[id] = 0;});}
  function assignAngles() {
    angle = {};
    function rec(id, a0, a1) {
      angle[id] = (a0 + a1) / 2;
      const cs = kids(id).map(cid => byId(cid)).sort((A, B) => (A.sibling_order ?? 0) - (B.sibling_order ?? 0) || String(A.label).localeCompare(String(B.label))).map(n => n.id);
      if (!cs.length) return;
      const step = (a1 - a0) / cs.length; cs.forEach((cid, i) => rec(cid, a0 + i * step, a0 + (i + 1) * step));
    }
    const r = rootId(); if (r) rec(r, ANG0, ANG1);
  }
  // Bands


  // Positions:
  function place() {
    pos = {};
    N.forEach((n, id) => {
      const d = depth[id] || 0;
      const a = (angle[id] ?? Math.PI / 2) + ROT;  // rotate
      const R = d ? ring(d) : 0;
      pos[id] = {x: R * Math.cos(a), y: R * Math.sin(a)};
    });
  }



  /* ===== draw ===== */
  function drawBands() {
    const maxD = Math.max(0, ...Object.values(depth));
    const data = d3.range(1, maxD + 1);

    // Shift by -π/2 so 0..π (node space) maps to bottom half in d3.arc space
    const bandArc = d3.arc()
      .startAngle(ANG0 + Math.PI / 2)  // -π/2 .. +π/2  => bottom semicircle
      .endAngle(ANG1 + Math.PI / 2)
      .innerRadius(d => ring(d - 1))
      .outerRadius(d => ring(d));

    const b = gBands.selectAll("path.band").data(data, d => d);
    b.enter().append("path").attr("class", "band")
      .merge(b)
      .attr("d", bandArc)
      .attr("fill", d => ["rgba(91,33,182,.10)", "rgba(76,29,149,.15)"][(d - 1) % 2])
      .attr("stroke", "rgba(76,29,149,.35)").attr("stroke-width", 0.7);
    b.exit().remove();
  }



  function drawEdges() {
    const s = gEdges.selectAll("path.edge").data(E.filter(e => N.has(e.source) && N.has(e.target)), d => d.source + "→" + d.target);
    s.enter().append("path").attr("class", "edge")
      .merge(s).attr("d", d => {const a = pos[d.source], b = pos[d.target]; if (!a || !b) return ""; const m = {x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 - .15 * Math.hypot(a.x - b.x, a.y - b.y)}; return `M${a.x},${a.y} Q${m.x},${m.y} ${b.x},${b.y}`;});
    s.exit().remove();
  }
  function drawNodes() {
    const data = [...N.values()];
    const n = gNodes.selectAll("text.node").data(data, d => d.id);
    n.enter().append("text").attr("class", "node").attr("text-anchor", "middle").attr("dominant-baseline", "middle")
      .on("click", (ev, d) => {   // open embedded toolbar (by URI id)
        ev.stopPropagation();
        sel = d.id; drawNodes();
        document.getElementById('tools').src = new URL('toolbar.html?id=' + d.id, location.href).toString();
        document.getElementById('panel').style.display = 'block';
      })
      .merge(n)
      .attr("x", d => pos[d.id]?.x || 0).attr("y", d => pos[d.id]?.y || 0)
      .classed("selected", d => d.id === sel)
      .style("font-size", d => `${Math.max(MINF, FONT - (depth[d.id] || 0) * SHRINK)}px`)
      .text(d => d.label || "•");
    n.exit().remove();
  }

  /* ===== zoom & click-off to close panel ===== */
  const zoom = d3.zoom().scaleExtent([0.3, 3]).on("zoom", ev => {g.attr("transform", ev.transform); const y = ev.transform.y; if (y < 8) {const z = d3.zoomTransform(svg.node()); svg.call(zoom.transform, d3.zoomIdentity.translate(z.x, z.y + (8 - y)).scale(z.k));} });
  svg.call(zoom);
  document.addEventListener('click', (e) => {
    const panel = document.getElementById('panel');
    if (panel.style.display === 'block' && !panel.contains(e.target) && e.target !== svg.node()) {
      panel.style.display = 'none';
    }
  });

  /* ===== double-click background: create node on ring edge at angle ===== */
  svg.on("dblclick", async (ev) => {
    if (ev.target !== svg.node()) return;                   // only background
    const p = d3.pointer(ev, svg.node());
    const [x, y] = d3.zoomTransform(svg.node()).invert(p);
    const r = Math.hypot(x, y);
    let d = Math.round(r / STEP); if (d < 1) d = 1;                   // nearest ring (>=1)
    let a = Math.atan2(y, x) - ROT;           // undo the visual rotation
    while (a < ANG0) a += 2 * Math.PI;           // normalize
    while (a > ANG1) a -= 2 * Math.PI;
    a = Math.max(ANG0, Math.min(ANG1, a));     // clamp to [0, π]
    const parent = sel || rootId(); if (!parent) return;

    // find insertion index by angle among siblings
    const ks = kids(parent);
    const ordered = ks.slice().sort((i, j) => (angle[i] ?? 0) - (angle[j] ?? 0));
    let idx = ordered.findIndex(k => a < (angle[k] ?? 0)); if (idx < 0) idx = ordered.length;

    const title = prompt("New node title?"); if (title == null) return;
    const {data: nw} = await sb.from('nodes').insert({graph_id: GRAPH_ID, label: title, sibling_order: idx, note_md: ''}).select().single();
    await sb.from('edges').insert({graph_id: GRAPH_ID, source: parent, target: nw.id});

    // bump later siblings' sibling_order
    for (let i = idx; i < ordered.length; i++) {
      const id = ordered[i]; const so = (byId(id).sibling_order ?? i) + 1;
      await sb.from('nodes').update({sibling_order: so}).eq('id', id);
      byId(id).sibling_order = so;
    }
    await load(); renderAll(false);
    sel = nw.id; drawNodes();
  });

  /* ===== IO + realtime ===== */
  function norm(n) {return {id: n.id, graph_id: n.graph_id ?? GRAPH_ID, label: n.label ?? 'Untitled', note_md: n.note_md ?? '', sibling_order: n.sibling_order ?? 0, deleted_at: n.deleted_at ?? null};}
  async function load() {
    const [ns, es] = await Promise.all([
      sb.from('nodes').select('*').eq('graph_id', GRAPH_ID).is('deleted_at', null),
      sb.from('edges').select('*').eq('graph_id', GRAPH_ID),
    ]);
    N.clear(); (ns.data || []).forEach(n => N.set(n.id, norm(n)));
    E = (es.data || []).map(e => ({source: e.source, target: e.target}));
    if (N.size === 0) {const {data: r} = await sb.from('nodes').insert({graph_id: GRAPH_ID, label: 'Root'}).select().single(); N.set(r.id, norm(r));}
  }
  function layout() {buildDepths(); assignAngles(); place();}
  function renderAll(center = true) {layout(); drawBands(); drawEdges(); drawNodes(); if (center) {const w = svg.node().clientWidth; svg.call(zoom.transform, d3.zoomIdentity.translate(w / 2, 40).scale(1));} }

  /* realtime: reflect toolbar edits immediately */
  sb.channel('rt-' + GRAPH_ID)
    .on('postgres_changes', {event: '*', schema: 'public', table: 'nodes', filter: `graph_id=eq.${GRAPH_ID}`}, async () => {await load(); renderAll(false);})
    .on('postgres_changes', {event: '*', schema: 'public', table: 'edges', filter: `graph_id=eq.${GRAPH_ID}`}, async () => {await load(); renderAll(false);})
    .subscribe();
  // Close the iframe panel when clicking anywhere outside it
  document.addEventListener("pointerdown", (e) => {
    const panel = document.getElementById("panel");
    if (panel.style.display === "block" && !panel.contains(e.target)) {
      panel.style.display = "none";
    }
  }, true); // capture phase so it always runs


  /* boot */
  (async function () {await load(); renderAll(true);})();
</script>
