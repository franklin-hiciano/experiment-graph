<!doctype html>
<meta charset="utf-8" />
<title>Radial Mindmap â€” viewer (minimal)</title>
<head><link rel="icon" type="image/png" href="logo.png">
<link rel="shortcut icon" type="image/png" href="logo.png">
</head>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,
  body {
    height: 100%;
    margin: 0;
    font: 14px system-ui, -apple-system, Segoe UI, Roboto
  }

  #wrap {
    position: relative;
    height: 100%
  }

  #svg {
    width: 100%;
    height: 100%;
    display: block;
    background: #fff
  }

  /* hamburger + graphs menu */
  #ham {
    position: absolute;
    top: 12px;
    left: 12px;
    z-index: 20;
    padding: 8px 10px;
    border: 1px solid #e5e7eb;
    border-radius: 10px;
    background: #fff;
    cursor: pointer
  }

  #gmenu {
    position: absolute;
    top: 52px;
    left: 12px;
    z-index: 20;
    width: 320px;
    max-height: 60vh;
    overflow: auto;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    background: #fff;
    box-shadow: 0 12px 32px rgba(0, 0, 0, .12);
    display: none
  }

  #gmenu .gmhead {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 10px;
    border-bottom: 1px solid #eef2f7;
    font-weight: 600
  }

  #glist .gitem {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 10px;
    cursor: pointer
  }

  #glist .gitem:hover {
    background: #f8fafc
  }

  #glist .name {
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis
  }

  #glist .ind {
    width: 10px;
    height: 10px;
    border-radius: 9999px;
    background: #cbd5e1
  }

  #glist .ind.current {
    background: #4f46e5
  }

  #glist .copy {
    border: 1px solid #d1d5db;
    border-radius: 8px;
    background: #fff;
    padding: 4px 8px;
    cursor: pointer
  }


  .edge {
    fill: none;
    stroke: #64748b;
    stroke-width: 1.25;
    opacity: .85;
    pointer-events: none
  }

  .band {
    vector-effect: non-scaling-stroke;
    pointer-events: none
  }

  .node {
    user-select: none;
    fill: #111827;
    cursor: pointer
  }

  .node.selected {
    font-weight: 700;
    fill: #1f2937
  }

  /* embedded toolbar panel (iframe only; no header/close) */
  #panel {
    position: absolute;
    top: 12px;
    right: 12px;
    width: 520px;
    height: 420px;
    background: #fff;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    box-shadow: 0 16px 36px rgba(0, 0, 0, .12);
    display: none;
    overflow: hidden;
    z-index: 10
  }

  #brand {
    color: purple;
    background-color: white;
    position: absolute;
    top: 0px;
    right: 0px;
    font-family: Courier, monospace;
    font-weight: 700;
    font-size: 28px;
    /* or whatever fits your theme */
    display: flex;
    align-items: center;
  }

  #brand .brand-a {
    color: purple;

    width: 28px;
    /* match roughly letter height */
    height: 28px;
    margin: 0 2px;
    object-fit: contain;
    vertical-align: middle;
  }


  #tools {
    width: 100%;
    height: 100%;
    border: 0
  }
</style>



<div id="wrap">
  <svg id="svg"></svg>
  <div id="panel"><iframe id="tools"></iframe></div>
  <button id="ham" title="Graphs">â˜°</button>
  <div id="gmenu">
    <div class="gmhead">
      <span>Graphs</span>
      <button id="newg" title="New graph">âž•</button>
    </div>
    <div id="glist"></div>
  </div>

</div>

<div id="brand">
  R
  <img src="logo.png" alt="A" class="brand-a">
  DIAL
</div>


<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
  /* ===== config ===== */
  const SUPABASE_URL = "https://gjdyushogvhuootdiwxz.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdqZHl1c2hvZ3ZodW9vdGRpd3h6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY4NTE3NTMsImV4cCI6MjA3MjQyNzc1M30.52heLq-Ic5DIXCZV0tCiv_VhubkY2-v3arq7InoI-sE";
  const GRAPH_ID = new URLSearchParams(location.search).get("graph") || "412dbeb5-7a9f-4bc7-a80a-8fd6e6d72465";
  const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  // nice, gentle tag colors; 0 = off
  const TAGS = [
    null,           // 0 = no tag
    "#8b5cf6",      // violet-500
    "#f59e0b",      // amber-500
    "#10b981",      // emerald-500
    "#06b6d4",      // cyan-500
    "#ef4444",      // red-500
    "#f472b6",      // pink-400
    "#94a3b8"       // slate-400
  ];


  /* ===== layout constants ===== */
  const STEP = 120;
  const ANG0 = 0, ANG1 = Math.PI;
  const ROT = 0;   // rotate +90Â° so weâ€™re the bottom semicircle
  const FONT = 16, SHRINK = 2, MINF = 10;

  /* ===== state ===== */
  const svg = d3.select("#svg");
  const g = svg.append("g"), gBands = g.append("g"), gEdges = g.append("g"), gNodes = g.append("g");
  let N = new Map(), E = [], depth = {}, angle = {}, pos = {}, sel = null;

  /* ===== helpers ===== */
  const byId = id => N.get(id);
  const kids = id => E.filter(e => e.source === id).map(e => e.target).filter(k => N.has(k));
  const rootId = () => {const inc = new Set(E.map(e => e.target)); for (const id of N.keys()) if (!inc.has(id)) return id; return [...N.keys()][0] || null;}
  const ring = d => d * STEP;

  /* ===== layout ===== */
  function buildDepths() {const r = rootId(); depth = {}; if (!r) return; depth[r] = 0; const q = [r]; while (q.length) {const u = q.shift(); for (const v of kids(u)) {depth[v] = (depth[u] || 0) + 1; q.push(v);} } N.forEach((_, id) => {if (depth[id] == null) depth[id] = 0;});}
  function assignAngles() {
    angle = {};
    function rec(id, a0, a1) {
      angle[id] = (a0 + a1) / 2;
      const cs = kids(id).map(cid => byId(cid)).sort((A, B) => (A.sibling_order ?? 0) - (B.sibling_order ?? 0) || String(A.label).localeCompare(String(B.label))).map(n => n.id);
      if (!cs.length) return;
      const step = (a1 - a0) / cs.length; cs.forEach((cid, i) => rec(cid, a0 + i * step, a0 + (i + 1) * step));
    }
    const r = rootId(); if (r) rec(r, ANG0, ANG1);
  }
  // Bands


  // Positions:
  function place() {
    pos = {};
    N.forEach((n, id) => {
      const d = depth[id] || 0;
      const a = (angle[id] ?? Math.PI / 2) + ROT;  // rotate
      const R = d ? ring(d) : 0;
      pos[id] = {x: R * Math.cos(a), y: R * Math.sin(a)};
    });
  }



  /* ===== draw ===== */
  function drawBands() {
    const maxD = Math.max(0, ...Object.values(depth));
    const data = d3.range(1, maxD + 1);

    // Shift by -Ï€/2 so 0..Ï€ (node space) maps to bottom half in d3.arc space
    const bandArc = d3.arc()
      .startAngle(ANG0 + Math.PI / 2)  // -Ï€/2 .. +Ï€/2  => bottom semicircle
      .endAngle(ANG1 + Math.PI / 2)
      .innerRadius(d => ring(d - 1))
      .outerRadius(d => ring(d));

    const b = gBands.selectAll("path.band").data(data, d => d);
    b.enter().append("path").attr("class", "band")
      .merge(b)
      .attr("d", bandArc)
      .attr("fill", d => ["rgba(91,33,182,.10)", "rgba(76,29,149,.15)"][(d - 1) % 2])
      .attr("stroke", "rgba(76,29,149,.35)").attr("stroke-width", 0.7);
    b.exit().remove();
  }



  function drawEdges() {
    const s = gEdges.selectAll("path.edge").data(E.filter(e => N.has(e.source) && N.has(e.target)), d => d.source + "â†’" + d.target);
    s.enter().append("path").attr("class", "edge")
      .merge(s).attr("d", d => {const a = pos[d.source], b = pos[d.target]; if (!a || !b) return ""; const m = {x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 - .15 * Math.hypot(a.x - b.x, a.y - b.y)}; return `M${a.x},${a.y} Q${m.x},${m.y} ${b.x},${b.y}`;});
    s.exit().remove();
  }
  function drawNodes() {
    const data = [...N.values()];

    // tag dots
    const dots = gNodes.selectAll("circle.tagdot")
      .data(data.filter(d => (d.tag || 0) > 0), d => d.id);

    dots.enter().append("circle")
      .attr("class", "tagdot")
      .attr("r", 4)
      .style("pointer-events", "none")
      .merge(dots)
      .attr("cx", d => (pos[d.id]?.x || 0) - 9)
      .attr("cy", d => (pos[d.id]?.y || 0) - 9)
      .attr("fill", d => TAGS[d.tag % TAGS.length] || "transparent");

    dots.exit().remove();

    // labels
    const n = gNodes.selectAll("text.node").data(data, d => d.id);
    n.enter().append("text")
      .attr("class", "node")
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "middle")
      .on("click", async (ev, d) => {                   // open toolbar
        ev.stopPropagation();
        sel = d.id; drawNodes();
        document.getElementById('tools').src =
          new URL('toolbar.html?id=' + d.id, location.href).toString();
        document.getElementById('panel').style.display = 'block';
      })
      .on("dblclick", async (ev, d) => {                 // add child
        ev.stopPropagation();
        const title = prompt("New node title?"); if (title == null) return;
        const cnt = kids(d.id).length;
        const {data: nw} = await sb.from('nodes')
          .insert({graph_id: GRAPH_ID, label: title, sibling_order: cnt, note_md: ''})
          .select().single();
        await sb.from('edges').insert({graph_id: GRAPH_ID, source: d.id, target: nw.id});
        await load(); renderAll(false);
        sel = nw.id; drawNodes();
      })
      .on("contextmenu", async (ev, d) => {             // cycle tag
        ev.preventDefault();
        const next = ((byId(d.id).tag || 0) + 1) % TAGS.length;
        await sb.from('nodes').update({tag: next}).eq('id', d.id);
        byId(d.id).tag = next;                           // optimistic
        drawNodes();
      })
      .merge(n)
      .attr("x", d => pos[d.id]?.x || 0)
      .attr("y", d => pos[d.id]?.y || 0)
      .classed("selected", d => d.id === sel)
      .style("font-size", d => `${Math.max(MINF, FONT - (depth[d.id] || 0) * SHRINK)}px`)
      .text(d => d.label || "â€¢");

    n.exit().remove();
  }


  /* ===== zoom & click-off to close panel ===== */
  const zoom = d3.zoom().scaleExtent([0.3, 3]).on("zoom", ev => {g.attr("transform", ev.transform); const y = ev.transform.y; if (y < 8) {const z = d3.zoomTransform(svg.node()); svg.call(zoom.transform, d3.zoomIdentity.translate(z.x, z.y + (8 - y)).scale(z.k));} });
  svg.call(zoom);
  document.addEventListener('click', (e) => {
    const panel = document.getElementById('panel');
    if (panel.style.display === 'block' && !panel.contains(e.target) && e.target !== svg.node()) {
      panel.style.display = 'none';
    }
  });

  /* ===== double-click background: create node on ring edge at angle ===== */
  svg.on("dblclick", async (ev) => {
    if (ev.target !== svg.node()) return;                   // only background
    const p = d3.pointer(ev, svg.node());
    const [x, y] = d3.zoomTransform(svg.node()).invert(p);
    const r = Math.hypot(x, y);
    let d = Math.round(r / STEP); if (d < 1) d = 1;                   // nearest ring (>=1)
    let a = Math.atan2(y, x) - ROT;           // undo the visual rotation
    while (a < ANG0) a += 2 * Math.PI;           // normalize
    while (a > ANG1) a -= 2 * Math.PI;
    a = Math.max(ANG0, Math.min(ANG1, a));     // clamp to [0, Ï€]
    const parent = sel || rootId(); if (!parent) return;

    // find insertion index by angle among siblings
    const ks = kids(parent);
    const ordered = ks.slice().sort((i, j) => (angle[i] ?? 0) - (angle[j] ?? 0));
    let idx = ordered.findIndex(k => a < (angle[k] ?? 0)); if (idx < 0) idx = ordered.length;

    const title = prompt("New node title?"); if (title == null) return;
    const {data: nw} = await sb.from('nodes').insert({graph_id: GRAPH_ID, label: title, sibling_order: idx, note_md: ''}).select().single();
    await sb.from('edges').insert({graph_id: GRAPH_ID, source: parent, target: nw.id});

    // bump later siblings' sibling_order
    for (let i = idx; i < ordered.length; i++) {
      const id = ordered[i]; const so = (byId(id).sibling_order ?? i) + 1;
      await sb.from('nodes').update({sibling_order: so}).eq('id', id);
      byId(id).sibling_order = so;
    }
    await load(); renderAll(false);
    sel = nw.id; drawNodes();
  });

  /* ===== IO + realtime ===== */
  function norm(n) {
    return {
      id: n.id, graph_id: n.graph_id ?? GRAPH_ID, label: n.label ?? 'Untitled',
      note_md: n.note_md ?? '', sibling_order: n.sibling_order ?? 0,
      share_token: n.share_token ?? null, deleted_at: n.deleted_at ?? null,
      tag: n.tag ?? 0
    };
  }

  async function load() {
    // fetch current nodes/edges (never assume data is present)
    const {data: ns = [], error: nerr} =
      await sb.from('nodes').select('*').eq('graph_id', GRAPH_ID).is('deleted_at', null);
    const {data: es = [], error: eerr} =
      await sb.from('edges').select('*').eq('graph_id', GRAPH_ID);

    N.clear(); ns.forEach(n => N.set(n.id, norm(n)));
    E = es.map(e => ({source: e.source, target: e.target}));

    // If graph is empty, try to seed a Root nodeâ€”but never assume success.
    if (ns.length === 0) {
      // (optional) ensure the graph row exists; ignore errors if you don't use a graphs table
      try {
        const {data: g} = await sb.from('graphs').select('id').eq('id', GRAPH_ID).maybeSingle?.() ?? {};
        if (!g) {
          await sb.from('graphs').insert({id: GRAPH_ID, name: 'Untitled'});
        }
      } catch (_) { }

      // try to create a root node
      let root = null;
      try {
        const {data, error} = await sb.from('nodes')
          .insert({graph_id: GRAPH_ID, label: 'Root', sibling_order: 0, note_md: ''})
          .select()
          .maybeSingle?.() ?? {};
        if (!error && data) root = data;
      } catch (_) { }

      // if insert failed (RLS/FK/etc), bail gracefully without crashing
      if (!root) {
        console.warn('Root seed failed (ok for locked graphs).');
        return; // renderAll() caller should handle empty N (or you can call it here to clear view)
      }

      N.set(root.id, norm(root));
    }
  }

  function layout() {buildDepths(); assignAngles(); place();}
  function renderAll(center = true) {layout(); drawBands(); drawEdges(); drawNodes(); if (center) {const w = svg.node().clientWidth; svg.call(zoom.transform, d3.zoomIdentity.translate(w / 2, 40).scale(1));} }

  /* realtime: reflect toolbar edits immediately */
  sb.channel('rt-' + GRAPH_ID)
    .on('postgres_changes', {event: '*', schema: 'public', table: 'nodes', filter: `graph_id=eq.${GRAPH_ID}`}, async () => {await load(); renderAll(false);})
    .on('postgres_changes', {event: '*', schema: 'public', table: 'edges', filter: `graph_id=eq.${GRAPH_ID}`}, async () => {await load(); renderAll(false);})
    .subscribe();
  // Close the iframe panel when clicking anywhere outside it
  document.addEventListener("pointerdown", (e) => {
    const panel = document.getElementById("panel");
    if (panel.style.display === "block" && !panel.contains(e.target)) {
      panel.style.display = "none";
    }
  }, true); // capture phase so it always runs


  /* boot */
  (async function () {await load(); renderAll(true);})();
</script>

<script>
  /* ---- graphs menu ---- */
  const ham = document.getElementById('ham');
  const menu = document.getElementById('gmenu');
  const glist = document.getElementById('glist');
  const newg = document.getElementById('newg');

  function graphUrl(id) {
    const url = new URL(location.href);
    url.search = '';
    url.searchParams.set('graph', id);
    return url.toString();
  }

  async function fetchGraphs() {
    // Fetch newest first; fall back to empty list if none/forbidden
    const {data: rows = []} = await sb.from('graphs').select('id,name,created_at').order('created_at', {ascending: false});
    return rows;
  }

  async function renderGraphs() {
    const rows = await fetchGraphs();
    glist.innerHTML = '';
    rows.forEach(row => {
      const item = document.createElement('div'); item.className = 'gitem';
      const ind = document.createElement('span'); ind.className = 'ind' + (row.id === GRAPH_ID ? ' current' : '');
      const name = document.createElement('div'); name.className = 'name'; name.textContent = row.name || '(untitled)';
      const copy = document.createElement('button'); copy.className = 'copy'; copy.textContent = 'ðŸ”—'; copy.title = 'Copy embed URL';

      copy.onclick = async (ev) => {ev.stopPropagation(); await navigator.clipboard.writeText(graphUrl(row.id)); copy.textContent = 'âœ…'; setTimeout(() => copy.textContent = 'ðŸ”—', 900);};
      item.onclick = () => {location.href = graphUrl(row.id);};

      item.append(ind, name, copy);
      glist.appendChild(item);
    });

    if (rows.length === 0) {
      const empty = document.createElement('div'); empty.className = 'gitem';
      empty.textContent = 'No graphs yet â€” create one âž•';
      glist.appendChild(empty);
    }
  }

  ham.addEventListener('click', async (e) => {
    e.stopPropagation();
    if (menu.style.display === 'block') {
      menu.style.display = 'none';
    } else {
      await renderGraphs();
      menu.style.display = 'block';
    }
  });

  newg.addEventListener('click', async (e) => {
    e.stopPropagation();
    const name = (prompt('New graph name?') || 'Untitled').trim();
    if (!name) return;
    // create graph
    let ins = await sb.from('graphs').insert({name}).select().single();
    if (ins.error) {
      // fallback: if your table has no default UUID, generate one client-side
      const id = ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
      ins = await sb.from('graphs').insert({id, name}).select().single();
    }
    if (ins.error) {alert('Create failed: ' + ins.error.message); return;}
    // jump to the new graph; your existing load() will create a root node on first render
    location.href = graphUrl(ins.data.id);
  });

  // Close menu when clicking anywhere else (keep your existing panel click-off too)
  document.addEventListener('pointerdown', (e) => {
    if (menu.style.display === 'block' && !menu.contains(e.target) && e.target !== ham) {
      menu.style.display = 'none';
    }
  }, true);

  // Optional: realtime refresh if someone else creates/renames graphs
  try {
    sb.channel('rt-graphs')
      .on('postgres_changes', {event: '*', schema: 'public', table: 'graphs'}, async () => {
        if (menu.style.display === 'block') await renderGraphs();
      })
      .subscribe();
  } catch { }
</script>
